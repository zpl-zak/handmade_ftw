<html><head><title>Handmade FTW</title><style>body{background-color:#f5f5f5;font-family:sans-serif}.Page{width:800px;margin:0 auto}p{font-size:15px;line-height:.4}h1,h2{color:green}a{text-decoration:none;color:green}a:hover{background-color:#faebd7}ul{list-style:none}pre{font-family:monospace;background-color:#fdf5e6;padding:10px;border:1px solid grey}table{border:1px solid grey;background-color:#fdf5e6;border-collapse:collapse}tr{border-bottom:1px solid grey}th{text-align:left;background-color:#ffe4c4;padding:5px;border-right:1px solid grey}td{padding:5px;border-right:1px solid grey}</style></head><body><div class="Page"><div class="Overview"><h1>$ Overview</h1><p>
Handmade FTW is a collection of header-only libraries for ease use of common algorithms.
</p>
<p>
Currently, Handmade FTW offers the following features:
<ul>
<table>
<tr>
<th>Filename</th>
<th>Description</th>
</tr>
<tr><td>hftw.h</td><td>Contains essential directives used by other libs.</td></tr>
<tr><td>hftw_mem.h</td><td>Handles memory allocation and management.</td></tr>
<tr><td>hftw_node.h</td><td>Linked list macro directives.</td></tr>
<tr><td>hftw_math.h</td><td>Linear algebra.</td></tr>
<tr><td>hftw_intrinsics.h</td><td>Intrinsics library.</td></tr>
<tr><td>hftw_math.h</td><td>String library providing easier and faster way of string manipulation.</td></tr>
<tr><td>hftw_platform.h</td><td>Platform-specific functions.</td></tr>
</table>
</ul>
</p></div><h1>$ Index</h1><ul><h2>Memory Arena</h2><li> <a href="#arena_header">arena_header</a> &nbsp; <small>Describes arena elements.</small></li><li> <a href="#memory_arena">memory_arena</a> &nbsp; <small>Memory arena holding contigous block of memory and tracking of pushed objects.</small></li><li> <a href="#arena_flags">arena_flags</a> &nbsp; <small>Arena flags.</small></li><li> <a href="#temp_memory">temp_memory</a> &nbsp; <small>Used to temporarily store short-living data in arena.</small></li><li> <a href="#arena_push_flag">arena_push_flag</a> &nbsp; <small>Push flags used by arena allocator.</small></li><li> <a href="#arena_push_params">arena_push_params</a> &nbsp; <small>Params used by allocator for customized allocation procedure.</small></li><li> <a href="#tag_scan_result">tag_scan_result</a> &nbsp; <small>Holds pointer to current element found by specified tag identification.</small></li><br><li> <a href="#DefaultTagScan">DefaultTagScan</a> &nbsp; <small>Default scan setup for new scans.</small></li><li> <a href="#ArenaInitialize">ArenaInitialize</a> &nbsp; <small>Initializes Memory Arena with default values.</small></li><li> <a href="#ArenaBuild">ArenaBuild</a> &nbsp; <small>Uses internal allocator to build new arena.</small></li><li> <a href="#ArenaGetAlignmentOffset">ArenaGetAlignmentOffset</a> &nbsp; <small>Calculates the offset required by specified alignment.</small></li><li> <a href="#ArenaDefaultParams">ArenaDefaultParams</a> &nbsp; <small>Returns default push state params.</small></li><li> <a href="#ArenaAlignNoClear">ArenaAlignNoClear</a> &nbsp; <small>Returns alignment arena push params without clear flag.</small></li><li> <a href="#ArenaAlign">ArenaAlign</a> &nbsp; <small>Returns alignment arena push params.</small></li><li> <a href="#ArenaNoClear">ArenaNoClear</a> &nbsp; <small>Returns arena push params without clear flag.</small></li><li> <a href="#ArenaExpect">ArenaExpect</a> &nbsp; <small>Returns arena push params with expected reserves.</small></li><li> <a href="#ArenaAlignExpect">ArenaAlignExpect</a> &nbsp; <small>Returns arena push params with expected reserves and alignment.</small></li><li> <a href="#ArenaTag">ArenaTag</a> &nbsp; <small>Returns arena push params with tag property.</small></li><li> <a href="#ArenaGetSizeRemaining">ArenaGetSizeRemaining</a> &nbsp; <small>Returns the remaining unused space size in arena.</small></li><li> <a href="#ArenaGetBlockByRecord">ArenaGetBlockByRecord</a> &nbsp; <small>Returns block of memory pointed to by index.</small></li><li> <a href="#ArenaGetBlockByTagAndRecord">ArenaGetBlockByTagAndRecord</a> &nbsp; <small>Returns tag scan result based on specified tag.</small></li><li> <a href="#ArenaGetEffectiveSizeFor">ArenaGetEffectiveSizeFor</a> &nbsp; <small>Returns effective size based on push params for specified initial size.</small></li><li> <a href="#ArenaHasRoomFor">ArenaHasRoomFor</a> &nbsp; <small>Returns truth value determining whether we have enough space in our arena depending on initial size requirements and push params.</small></li><li> <a href="#ArenaPushSize_">ArenaPushSize_</a> &nbsp; <small>Asks our arena for plotting a block of memory determined by initial size and params requirements.</small></li><li> <a href="#ArenaPushString">ArenaPushString</a> &nbsp; <small>Pushes null-terminated string to the arena.</small></li><li> <a href="#ArenaPushAndNullTerminate">ArenaPushAndNullTerminate</a> &nbsp; <small>Pushes string of specified size to the arena and additionally null-terminates it.</small></li><li> <a href="#ArenaBeginTemporaryMemory">ArenaBeginTemporaryMemory</a> &nbsp; <small>Tells our arena we plan to store temporary memory in it.</small></li><li> <a href="#ArenaEndTemporaryMemory">ArenaEndTemporaryMemory</a> &nbsp; <small>Tells our arena we`re done serving temporary memory and resets it back to its original state.</small></li><li> <a href="#ArenaClear">ArenaClear</a> &nbsp; <small>Clears the whole arena.</small></li><li> <a href="#ArenaCheck">ArenaCheck</a> &nbsp; <small>Checks whether our arena is still holding temporary data.</small></li><li> <a href="#ArenaSub">ArenaSub</a> &nbsp; <small>Creates sub-arena inside of our arena, with specified size and push params.</small></li><li> <a href="#ArenaCleanUnusedRoom">ArenaCleanUnusedRoom</a> &nbsp; <small>Clean unused reserved space in our arena.</small></li><li> <a href="#ArenaFree">ArenaFree</a> &nbsp; <small>Deallocate our arena.</small></li><br><li> <a href="#ArenaGetBlock">ArenaGetBlock</a> &nbsp; <small>Returns block of memory pointed to by index. *NOTE* Works only with arena`s elements of uniform size!</small></li><li> <a href="#ArenaGetVaryBlock">ArenaGetVaryBlock</a> &nbsp; <small>Returns element by index.</small></li><li> <a href="#ArenaGetVaryBlockTagValue">ArenaGetVaryBlockTagValue</a> &nbsp; <small>Returns element`s value by tag.</small></li><li> <a href="#ArenaGetVaryBlockTagResult">ArenaGetVaryBlockTagResult</a> &nbsp; <small>Returns tag scan result by tag.</small></li></ul><h1>$ Content</h1><ul><div id="arena_header" class="doc"><h2>arena_header</h2><pre>
typedef struct
{
    s32 Size;    // Size of the element.
    u32 Tag;     // Element's tag used for identification.
    u32 Offset;  // Memory offset from the base.
} arena_header;
</pre><p>Describes arena elements.</p></div><div id="memory_arena" class="doc"><h2>memory_arena</h2><pre>
typedef struct
{
    memory_index Size;             // Allocated memory size. 
    uint8 *Base;                   // Memory base pointer. (Points to a contigous block of memory.)
    memory_index Used;             // Memory already used by elements.
    u8 Flags;                      // Arena's flags.
    b32 WasExpanded;               // If reallocation is allowed, this signals us whether memory expansion has happened.

    s32 TempCount;                 // Counts how many times is our arena used by temp_memory.
    
    Node_arena_header *Header;    // Linked list of tracked elements.
    Node_arena_header *HeaderEnd;
} memory_arena;
</pre><p>Memory arena holding contigous block of memory and tracking of pushed objects.</p></div><div id="arena_flags" class="doc"><h2>arena_flags</h2><pre>
typedef enum
{
    ArenaFlag_AllowRealloc = 0x1,    // Allows re-allocation of the memory, if expansion is required.
    ArenaFlag_DisallowHeaders = 0x2, // Disallows tracking of elements. Useful if elements are of uniform size.
} arena_flags;
</pre><p>Arena flags.</p></div><div id="temp_memory" class="doc"><h2>temp_memory</h2><pre>
typedef struct
{
    memory_arena *Arena;  // Memory Arena to be used.
    memory_index Used;    // This holds the Arena's original used size.
} temp_memory;
</pre><p>Used to temporarily store short-living data in arena.</p></div><div id="arena_push_flag" class="doc"><h2>arena_push_flag</h2><pre>
typedef enum
{
    ArenaPushFlag_ClearToZero = 0x1,  // Tell the allocator to clear allocated memory.
} arena_push_flag;
</pre><p>Push flags used by arena allocator.</p></div><div id="arena_push_params" class="doc"><h2>arena_push_params</h2><pre>
typedef struct
{
    u32 Flags;        // Specifies push flags. @see arena_push_flag
    u32 Alignment;    // Specifies memory alignment requirements.
    u32 Expectation;  // This tells the allocator to check whether we have enough reserved memory up-front.
    u32 Tag;          // Tag used for identification in pushed element.
} arena_push_params;
</pre><p>Params used by allocator for customized allocation procedure.</p></div><div id="tag_scan_result" class="doc"><h2>tag_scan_result</h2><pre>
typedef struct
{
    u8 *Value;                // Pointer to memory tagged by identification.
    Node_arena_header *Node;  // Pointer to found element.
} tag_scan_result;
</pre><p>Holds pointer to current element found by specified tag identification.</p></div><div id="DefaultTagScan" class="doc"><h2>DefaultTagScan</h2><pre>
inline tag_scan_result
DefaultTagScan(void)
</pre><p>Default scan setup for new scans.</p></div><div id="ArenaInitialize" class="doc"><h2>ArenaInitialize</h2><pre>
inline void
ArenaInitialize(memory_arena *Arena, // Arena to be initialized.
                memory_index Size,   // Size of the allocated memory.
                void *Base)          // Memory block to be used with Arena.
</pre><p>Initializes Memory Arena with default values.</p><b>Example:</b> <code>ArenaInitialize(Arena, 128, MemBlock);</code></div><div id="ArenaBuild" class="doc"><h2>ArenaBuild</h2><pre>
inline void
ArenaBuild(memory_arena *Arena, // Arena to be built.
           memory_index Size)   // The size to be pre-allocated.
</pre><p>Uses internal allocator to build new arena.</p><b>Example:</b> <code>ArenaBuild(Arena, 128);</code></div><div id="ArenaGetAlignmentOffset" class="doc"><h2>ArenaGetAlignmentOffset</h2><pre>
inline memory_index
ArenaGetAlignmentOffset(memory_arena *Arena,     // Target Arena.
                        memory_index Alignment)  // Desired alignment
</pre><p>Calculates the offset required by specified alignment.</p><b>Example:</b> <code>ArenaGetAlignmentOffset(Arena, 8);</code></div><div id="ArenaDefaultParams" class="doc"><h2>ArenaDefaultParams</h2><pre>
inline arena_push_params
ArenaDefaultParams(void)
</pre><p>Returns default push state params.</p></div><div id="ArenaAlignNoClear" class="doc"><h2>ArenaAlignNoClear</h2><pre>
inline arena_push_params
ArenaAlignNoClear(
u32 Alignment)      // Memory alignment we require during allocation.
</pre><p>Returns alignment arena push params without clear flag.</p></div><div id="ArenaAlign" class="doc"><h2>ArenaAlign</h2><pre>
inline arena_push_params
ArenaAlign(u32 Alignment, // Memory alignment we require during allocation.
           b32 Clear)     // Should allocator clear allocated memory?
</pre><p>Returns alignment arena push params.</p></div><div id="ArenaNoClear" class="doc"><h2>ArenaNoClear</h2><pre>
inline arena_push_params
ArenaNoClear(void)
</pre><p>Returns arena push params without clear flag.</p></div><div id="ArenaExpect" class="doc"><h2>ArenaExpect</h2><pre>
inline arena_push_params
ArenaExpect(u32 Expectation, // Expected memory to be in reserves.
            b32 Clear)       // Should allocator clear allocated memory?
</pre><p>Returns arena push params with expected reserves.</p></div><div id="ArenaAlignExpect" class="doc"><h2>ArenaAlignExpect</h2><pre>
inline arena_push_params
ArenaAlignExpect(u32 Alignment,   // Memory alignment we require during allocation.
                 u32 Expectation, // Expected memory to be in reserves.
                 b32 Clear)       // Should allocator clear allocated memory?
</pre><p>Returns arena push params with expected reserves and alignment.</p></div><div id="ArenaTag" class="doc"><h2>ArenaTag</h2><pre>
inline arena_push_params
ArenaTag(u32 Tag,                 // Tag used for element lookup.
         arena_push_params Rest)  // Rest of the push params. @see arena_push_params
</pre><p>Returns arena push params with tag property.</p></div><div id="ArenaGetSizeRemaining" class="doc"><h2>ArenaGetSizeRemaining</h2><pre>
inline memory_index
ArenaGetSizeRemaining(memory_arena *Arena,      // Target arena
                      arena_push_params Params) // Params to be used during the procedure.
</pre><p>Returns the remaining unused space size in arena.</p></div><div id="ArenaGetBlockByRecord" class="doc"><h2>ArenaGetBlockByRecord</h2><pre>
inline void *
ArenaGetBlockByRecord(memory_arena *Arena, // Target arena
                      size_t Index)        // Element index
</pre><p>Returns block of memory pointed to by index.</p></div><div id="ArenaGetBlockByTagAndRecord" class="doc"><h2>ArenaGetBlockByTagAndRecord</h2><pre>
inline tag_scan_result
ArenaGetBlockByTagAndRecord(memory_arena *Arena,  // Target arena
                            tag_scan_result scan, // Previous scan result. (Or DefaultTagScan if none. @see DefaultTagScan)
                            u32 Tag)              // Tag used for lookup.
</pre><p>Returns tag scan result based on specified tag.</p></div><div id="ArenaGetEffectiveSizeFor" class="doc"><h2>ArenaGetEffectiveSizeFor</h2><pre>
inline memory_index
ArenaGetEffectiveSizeFor(memory_arena *Arena,      // Target arena
                         memory_index SizeInit,    // Initial size required by callee.
                         arena_push_params Params) // Params to be used during the procedure.
</pre><p>Returns effective size based on push params for specified initial size.</p></div><div id="ArenaHasRoomFor" class="doc"><h2>ArenaHasRoomFor</h2><pre>
inline b32
ArenaHasRoomFor(memory_arena *Arena,       // Target arena
                memory_index SizeInit,     // Initial size required by callee.
                arena_push_params Params)  // Params to be used during the procedure.
</pre><p>Returns truth value determining whether we have enough space in our arena depending on initial size requirements and push params.</p></div><div id="ArenaPushSize_" class="doc"><h2>ArenaPushSize_</h2><pre>
inline void *
ArenaPushSize_(memory_arena *Arena,         // Target arena
               memory_index SizeInit,       // Initial size required by callee.
               arena_push_params Params)    // Params to be used during the procedure.
</pre><p>Asks our arena for plotting a block of memory determined by initial size and params requirements.</p></div><div id="ArenaPushString" class="doc"><h2>ArenaPushString</h2><pre>
inline char *
ArenaPushString(memory_arena *Arena, // Target arena
                const char *Source)  // String source
</pre><p>Pushes null-terminated string to the arena.</p></div><div id="ArenaPushAndNullTerminate" class="doc"><h2>ArenaPushAndNullTerminate</h2><pre>
inline char *
ArenaPushAndNullTerminate(memory_arena *Arena, // Target arena
                          u32 Length,          // String length
                          const char *Source)  // String source
</pre><p>Pushes string of specified size to the arena and additionally null-terminates it.</p></div><div id="ArenaBeginTemporaryMemory" class="doc"><h2>ArenaBeginTemporaryMemory</h2><pre>
inline temp_memory
ArenaBeginTemporaryMemory(
memory_arena *Arena) // Target arena
</pre><p>Tells our arena we plan to store temporary memory in it.</p></div><div id="ArenaEndTemporaryMemory" class="doc"><h2>ArenaEndTemporaryMemory</h2><pre>
inline void
ArenaEndTemporaryMemory(
temp_memory TempMem) // Structure holding our arena's pointer and originally used size. @see temp_memory
</pre><p>Tells our arena we`re done serving temporary memory and resets it back to its original state.</p></div><div id="ArenaClear" class="doc"><h2>ArenaClear</h2><pre>
inline void
ArenaClear(
memory_arena *Arena) // Target arena
</pre><p>Clears the whole arena.</p></div><div id="ArenaCheck" class="doc"><h2>ArenaCheck</h2><pre>
inline void
ArenaCheck(memory_arena *Arena)
</pre><p>Checks whether our arena is still holding temporary data.</p></div><div id="ArenaSub" class="doc"><h2>ArenaSub</h2><pre>
inline void
ArenaSub(memory_arena *Result,     // Target SubArena
         memory_arena *Arena,      // Target Arena
         memory_index Size,        // Initial size required by callee.
         arena_push_params Params) // Params to be used during the procedure.
</pre><p>Creates sub-arena inside of our arena, with specified size and push params.</p></div><div id="ArenaCleanUnusedRoom" class="doc"><h2>ArenaCleanUnusedRoom</h2><pre>
inline void
ArenaCleanUnusedRoom(
memory_arena * Arena) // Target arena
</pre><p>Clean unused reserved space in our arena.</p></div><div id="ArenaFree" class="doc"><h2>ArenaFree</h2><pre>
inline void
ArenaFree(
memory_arena * Arena) // Target arena
</pre><p>Deallocate our arena.</p></div><div id="ArenaGetBlock" class="doc"><h2>ArenaGetBlock</h2><p>Returns block of memory pointed to by index. *NOTE* Works only with arena`s elements of uniform size!</p><b>Example:</b> <code>(Type *) ArenaGetBlock(Arena, Type, Index)</code></div><div id="ArenaGetVaryBlock" class="doc"><h2>ArenaGetVaryBlock</h2><p>Returns element by index.</p><b>Example:</b> <code>(Type *) ArenaGetVaryBlock(Arena, Type, Index)</code></div><div id="ArenaGetVaryBlockTagValue" class="doc"><h2>ArenaGetVaryBlockTagValue</h2><p>Returns element`s value by tag.</p><b>Example:</b> <code>(Type *) ArenaGetVaryBlockTagValue(Arena, Scan, Type, Tag)</code></div><div id="ArenaGetVaryBlockTagResult" class="doc"><h2>ArenaGetVaryBlockTagResult</h2><p>Returns tag scan result by tag.</p><b>Example:</b> <code>tag_scan_result ArenaGetVaryBlockTagResult(Arena, Scan, Tag)</code></div></ul></div></body></html>